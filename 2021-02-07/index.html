<h1 id="trusted-programming-our-rust-mission-at-huawei">Trusted Programming: Our Rust Mission at Huawei</h1>
<p>Dr. Yijun Yu</p>
<p>Chief Expert on Trusted Programming<br />
Trustworthy Open-Source Software Engineering Lab<br />
Huawei Technology, Inc.</p>
<p>Dr. Amanieu d'Antras</p>
<p>Principal Rust Expert<br />
Trustworthy Open-Source Software Engineering Lab<br />
Huawei Technology, Inc.</p>
<h2 id="innovations-by-rust">Innovations by Rust</h2>
<p>Since 2015, Rust has consistently been voted as the most loved programming language in the StackOverflow survey.</p>
<p><img src="img/RustConChina2020-yu-v42.png" width="400" /><br />
There has also been an increasing number of publications on Rust at recent top programming languages and software engineering conferences.</p>
<p><img src="img/RustConChina2020-yu-v43.png" /><br />
If that's not enough, a recent Nature 2020 article, `Why Scientists are Turning to Rust', says that there is increasining momentum on the adoption of Rust amongst scientists.</p>
<p><img src="img/RustConChina2020-yu-v41.png" width="400" /><br />
## Initial adoption of Rust at Huawei</p>
<p>At Huawei, we aim to engineer trustworthy software systems in the world's largest telecom industry.</p>
<p>For example, we are working to migrate parts of our code base towards Rust, which is safer and as performant as C/C++. To assist our developers in this process, we are leveraging the open-source <a href="https://c2rust.com/">C2Rust</a> transpiler to generate Rust code directly from C. We have created automated tools to refactor and clean up this generated Rust code through source-to-source transformations.</p>
<p>We also contribute significant features back to the Rust community. For example, our recent contributions to the Rust compiler enable the compilation of Rust programs for big-endian and <a href="https://developer.arm.com/documentation/dai0490/latest/">ILP32</a> variants of AArch64. These changes enable Huawei and other hardware companies to run Rust code on networking hardware which commonly use these architecture variants. This contribution is achieved with the help of our Rust expert Amanieu d'Antras, who has pushed through these pull requests to <a href="https://reviews.llvm.org/rG21bfd068b32ece1c6fbc912208e7cd1782a8c3fc">the LLVM compiler</a>, <a href="https://github.com/rust-lang/libc/pull/2039">the libc crate</a>, and <a href="https://github.com/rust-lang/rust/pull/81455">the Rust compiler itself</a>. These changes introduce new end-to-end cross-compilation targets for the Rust compiler, making it easier to build Rust products for bespoke hardware using a single command:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">cargo</span> build --target aarch64_be-unknown-linux-gnu
<span class="kw">cargo</span> build --target aarch64-unknown-linux-gnu_ilp32
<span class="kw">cargo</span> build --target aarch64_be-unknown-linux-gnu_ilp32</code></pre></div>
<p>Finally, we are developing a rich set of internal Rust libraries in Rust built around an actor-based concurrency paradigm. This simplifies asynchronuous programming by leveraging Rust language features such as <code>async</code>, <code>await</code>, etc.</p>
<p>With respect to community engagement, Huawei has been leading the effort in China, hosting the first Chinese Rust Conference during December 26-27 in Shenzhen. We have started to lead the community by carrying out a number of activities, including creating Rust tutorials and Rust coding conventions in Chinese for a vast number of developers who are interested in Rust.</p>
<p>All these factors have led to increased adoption of Rust withing Huawei and a smooth migration from C/C++ programs, which are dominant in the telecom industry. As the leading company in this industry and a founding member of the Rust Foundation, Huawei is committed to the success of Rust and will continue contributing back to the Rust community.</p>
<h2 id="c-to-rust-transpilation">C to Rust transpilation</h2>
<p>To illustrate, one can take a close look at the following C program, implementing the `100 doors' algorithm taken from Rosetta Code.</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="ot">#include &lt;stdio.h&gt;</span>
 
<span class="dt">int</span> main()
{
  <span class="dt">char</span> is_open[<span class="dv">100</span>] = { <span class="dv">0</span> };
  <span class="dt">int</span> pass, door;
 
  <span class="co">/* do the 100 passes */</span>
  <span class="kw">for</span> (pass = <span class="dv">0</span>; pass &lt; <span class="dv">100</span>; ++pass)
    <span class="kw">for</span> (door = pass; door &lt; <span class="dv">100</span>; door += pass<span class="dv">+1</span>)
      is_open[door] = !is_open[door];
 
  <span class="co">/* output the result */</span>
  <span class="kw">for</span> (door = <span class="dv">0</span>; door &lt; <span class="dv">100</span>; ++door)
    printf(<span class="st">&quot;door #%d is %s.</span><span class="ch">\n</span><span class="st">&quot;</span>, door<span class="dv">+1</span>, (is_open[door]? <span class="st">&quot;open&quot;</span> : <span class="st">&quot;closed&quot;</span>));
 
  <span class="kw">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>The <a href="https://github.com/immunant/c2rust">c2rust</a> transpiler initially produces the following Rust code:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#![</span>allow<span class="at">(</span>dead_code<span class="at">,</span> mutable_transmutes<span class="at">,</span> non_camel_case_types<span class="at">,</span> non_snake_case<span class="at">,</span>
         non_upper_case_globals<span class="at">,</span> unused_assignments<span class="at">,</span> unused_mut<span class="at">)]</span>
<span class="at">#![</span>register_tool<span class="at">(</span>c2rust<span class="at">)]</span>
<span class="at">#![</span>feature<span class="at">(</span>main<span class="at">,</span> register_tool<span class="at">)]</span>
<span class="kw">extern</span> <span class="st">&quot;C&quot;</span> {
    <span class="at">#[</span>no_mangle<span class="at">]</span>
    <span class="kw">fn</span> printf(_: *<span class="kw">const</span> libc::<span class="dt">c_char</span>, _: ...) -&gt; libc::<span class="dt">c_int</span>;
}
<span class="kw">unsafe</span> <span class="kw">fn</span> main_0() -&gt; libc::<span class="dt">c_int</span> {
    <span class="kw">let</span> <span class="kw">mut</span> is_open: [libc::<span class="dt">c_char</span>; <span class="dv">100</span>] =
        [<span class="dv">0</span> <span class="kw">as</span> libc::<span class="dt">c_int</span> <span class="kw">as</span> libc::<span class="dt">c_char</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
         <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
         <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
         <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>,
         <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>];
    <span class="kw">let</span> <span class="kw">mut</span> pass: libc::<span class="dt">c_int</span> = <span class="dv">0</span>;
    <span class="kw">let</span> <span class="kw">mut</span> door: libc::<span class="dt">c_int</span> = <span class="dv">0</span>;
    <span class="co">/* do the 100 passes */</span>
    pass = <span class="dv">0</span> <span class="kw">as</span> libc::<span class="dt">c_int</span>;
    <span class="kw">while</span> pass &lt; <span class="dv">100</span> <span class="kw">as</span> libc::<span class="dt">c_int</span> {
        door = pass;
        <span class="kw">while</span> door &lt; <span class="dv">100</span> <span class="kw">as</span> libc::<span class="dt">c_int</span> {
            is_open[door <span class="kw">as</span> <span class="dt">usize</span>] =
                (is_open[door <span class="kw">as</span> <span class="dt">usize</span>] == <span class="dv">0</span>) <span class="kw">as</span> libc::<span class="dt">c_int</span> <span class="kw">as</span> libc::<span class="dt">c_char</span>;
            door += pass + <span class="dv">1</span> <span class="kw">as</span> libc::<span class="dt">c_int</span>
        }
        pass += <span class="dv">1</span>
    }
    <span class="co">/* output the result */</span>
    door = <span class="dv">0</span> <span class="kw">as</span> libc::<span class="dt">c_int</span>;
    <span class="kw">while</span> door &lt; <span class="dv">100</span> <span class="kw">as</span> libc::<span class="dt">c_int</span> {
        printf(b<span class="st">&quot;door #%d is %s.</span><span class="sc">\n\x00</span><span class="st">&quot;</span> <span class="kw">as</span> *<span class="kw">const</span> <span class="dt">u8</span> <span class="kw">as</span> *<span class="kw">const</span> libc::<span class="dt">c_char</span>,
               door + <span class="dv">1</span> <span class="kw">as</span> libc::<span class="dt">c_int</span>,
               <span class="kw">if</span> is_open[door <span class="kw">as</span> <span class="dt">usize</span>] <span class="kw">as</span> libc::<span class="dt">c_int</span> != <span class="dv">0</span> {
                   b<span class="st">&quot;open</span><span class="sc">\x00</span><span class="st">&quot;</span> <span class="kw">as</span> *<span class="kw">const</span> <span class="dt">u8</span> <span class="kw">as</span> *<span class="kw">const</span> libc::<span class="dt">c_char</span>
               } <span class="kw">else</span> { b<span class="st">&quot;closed</span><span class="sc">\x00</span><span class="st">&quot;</span> <span class="kw">as</span> *<span class="kw">const</span> <span class="dt">u8</span> <span class="kw">as</span> *<span class="kw">const</span> libc::<span class="dt">c_char</span> });
        door += <span class="dv">1</span>
    }
    <span class="kw">return</span> <span class="dv">0</span> <span class="kw">as</span> libc::<span class="dt">c_int</span>;
}
<span class="at">#[</span>main<span class="at">]</span>
<span class="kw">pub</span> <span class="kw">fn</span> main() { <span class="kw">unsafe</span> { ::std::process::exit(main_0() <span class="kw">as</span> <span class="dt">i32</span>) } }</code></pre></div>
<p>Although it is compilable, the resulting code is unmaintanable and places too much responsibility on programmers to ensure its safety because all functions are marked as <code>unsafe</code>. Although the <code>c2rust</code> transpiler supports refactoring commands, it is rather ad hoc, requiring further tweaking with extra help of experienced Rust programmers.</p>
<p>To take advantage of the safety guarantees of the Rust language, we have chosen to leverage <a href="http://txl.ca">TXL</a>, an efficient source-to-source transformation tool. We have developed a robust Rust parser for TXL and used to develop automated refactoring patterns with a guarantee of correct semantics, which allows us to achieve much safer and more maintainable Rust code, e.g.,</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="co">// #include &lt;stdio.h&gt;</span>
<span class="kw">fn</span> main() {
    <span class="kw">let</span> <span class="kw">mut</span> is_open: [<span class="dt">i8</span>; <span class="dv">100</span>] = [<span class="dv">0</span>; <span class="dv">100</span>];
    <span class="kw">for</span> pass <span class="kw">in</span> <span class="dv">0.</span>.<span class="dv">100</span> {
        <span class="kw">let</span> <span class="kw">mut</span> door = pass <span class="kw">as</span> <span class="dt">usize</span>;
        <span class="kw">while</span> door &lt; <span class="dv">100</span> {
            is_open[door] = !is_open[door];
            door += pass + <span class="dv">1</span>;
        }
    }
    <span class="kw">for</span> door <span class="kw">in</span> <span class="dv">0.</span>.<span class="dv">100</span> {
        <span class="pp">print!</span>(
            <span class="st">&quot;door #{} is {}.</span><span class="sc">\n</span><span class="st">&quot;</span>,
            door + <span class="dv">1</span>,
            (<span class="kw">if</span> (is_open[door]) != <span class="dv">0</span> {
                <span class="st">&quot;open&quot;</span>
            } <span class="kw">else</span> {
                <span class="st">&quot;closed&quot;</span>
            })
        );
    }
}</code></pre></div>
<p>As one can see, there are no more <code>unsafe</code> blocks and the code is fully understandable by programmers.</p>
<h2 id="adapting-end-to-end-rust-tooling-for-huawei">Adapting end-to-end Rust tooling for Huawei</h2>
<p>There are many end-to-end tools out there in the Rust community and we have started to benefit from the interactions with developers of these tools.</p>
<p>Here are just a few examples.</p>
<h3 id="tokei"><code>tokei</code></h3>
<p>Because trustworthy programming typically involves migrating programming languages, we have adopted <a href="https://github.com/XAMPPRocky/tokei"><code>tokei</code></a> as our code complexity metric tool, which can recognise as many as 200 languages. For example, the following statistics show how many lines of code various programming languages have been developed in Google's Fucshia project:</p>
<p><img src="img/RustConChina2020-yu-v49.png" /><br />
It is relatively easy to plot the proportion of C, C++, Rust code in the evolution of Fucshia, as follows:</p>
<p><img src="img/RustConChina2020-yu-v410.png" /><br />
To accommodate the needs to processing multiple programming languages in our projects, we have made a <a href="https://github.com/XAMPPRocky/tokei/pull/678">pull request to <code>tokei</code></a> to support batch processing of recognized languages.</p>
<h3 id="cargo-geiger"><code>cargo-geiger</code></h3>
<p>To improve safety, we would like as much code as possible to be checked by the Rust compiler. Fortunately, <a href="https://github.com/rust-secure-code/cargo-geiger"><code>cargo-geiger</code></a> does almost this by counting the statistics of <code>unsafe</code> items such as <code>fn</code>, <code>expr</code>, <code>struct</code>, <code>impl</code>, <code>trait</code>, and their occurrences in various dependent crates:</p>
<p><img src="img/RustConChina2020-yu-v411.png" /><br />
However, the statistics do not reflect the ratio of safe items, hence not showing how much has been achieved overall for Rust projects. Therefore, we made a <a href="https://github.com/rust-secure-code/cargo-geiger/pull/167">pull request</a> to <code>cargo-geiger</code> to report the checked safe ratios of Rust projects. After it was accepted, this tool has been used regularly by our product teams on daily basis. A report will look like the following, which has made it easier to tell which crates have not been fully checked by the Rust compiler:</p>
<p><img src="img/RustConChina2020-yu-v412.png" /><br />
<img src="img/RustConChina2020-yu-v413.png" /><br />
</p>
<h2 id="research-on-rust-through-deep-code-learning">Research on Rust through Deep Code Learning</h2>
<p>As code bases from the Rust open-source community evolve and grow, new developers need to learn the best practices, including but not limited to the language itself. Statistical machine learning methods from large amount of source code, also known as <a href="https://arxiv.org/abs/1709.06182">Big Code</a>, has been considered by software engineering research communities: similar to the machine learning problems for image processing and natural language processing where vast number of features requires deep neural networks (DNN) to extract, big code may also be used to train a DNN to reflect on statistical patterns of programs, which is called `Deep Code Learning'.</p>
<p>In this respect, Huawei is pushing the limits by improving the state-of-the-art of `cross-language' deep code learning.</p>
<p>For example, initial deep code learning methods are trained and evaluated using the benchmarks of 52,000 C/C++ programs of 104 algorithm classes collected from the programming courses of Peking University. Traditionally, tree-based convolution neural networks (TBCNN) could achieve 94% accuracy in algorithm classification for this dataset <a href="https://github.com/bdqnghi/tbcnn.tensorflow">(AAAI'16)</a>. A recent progress of the SOTA using abstract syntax trees at the statement level <a href="https://github.com/zhangj111/astnn">(ICSE'19)</a> achieved 98% accuracy. Our recent progress pushes the SOTA even higher to achieve 98.4% accuracy <a href="https://arxiv.org/abs/2009.09777">(AAAI'21)</a> by an innovation on Tree-based Capsule Networks.</p>
<p>Earlier, we have used cross-language datasets to show that the learnt model of one language is applicable to another programming language. For example, using the Rosetta Code datasets from Github, we show it possible to obtain 86% accuracy for algorithm classification (Java to C) <a href="https://github.com/bdqnghi/bi-tbcnn">(SANER'19)</a>, and cross-language API mapping problems (Java to C#) <a href="https://github.com/bdqnghi/SAR_API_mapping">(ESEC/FSE'19)</a>. These statistical language models have found multiple applications to software engineering, in terms of code classification, code search, code recommendation, code summary, method name prodiction, and code clone detection <a href="https://github.com/bdqnghi/infercode">(ICSE'21)</a>.</p>
<p>To analyse Rust projects, we have made another pull request to the Rust parser project <a href="https://github.com/tree-sitter/tree-sitter/pull/863"><code>tree-sitter</code></a> and XML serialization crate <a href="https://github.com/tafia/quick-xml/pull/250"><code>quick-xml</code></a>, which allow us to feed the abstract syntax trees of Rust programs to train a deep code learning model. The preliminary results are quite promising, the detection algorithms in Rust can reach an accuracy as high as 85.5%. This number is still climbing as we continue working on improving toolchains.</p>
<h2 id="conclusion">Conclusion</h2>
<p>In summary, the Huawei Trustworthy Open-Source Software Engineering Lab is working hard to provide programmers an end-to-end IDE toolchain that intelligently assists in maximizing safety and performance. A prototype of such an IDE is shown as an extension to the Visual Studio Codeï¼Œwhere programmers are assisted with the recommendation of a suitable algorithm and an explanation of the choice. <img src="img/RustConChina2020-yu-v414.png" /><br />
</p>
<p>A journey towards the vision of Trusted Programming has just begun and we hope to work collaboratively with the Rust community, and the upcoming Rust Foundation, to lead a smooth revolution to the Telecom software industry.</p>
